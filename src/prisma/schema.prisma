generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch"]
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_CONNECTION_POOL_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model Drop {
  id                  Int         @id @default(autoincrement())
  name                String
  whitelistId         Int?
  createdAt           DateTime    @default(now())
  approvedAt          DateTime?
  approvedBy          String?     @db.Char(42)
  bannerImageS3Path   String
  description         String
  artistAddress       String      @db.Char(42)
  featuredMediaS3Path String?
  mobileCoverS3Path   String?
  tileImageS3Path     String?
  ApprovedByUser      User?       @relation("Drop_approvedByToUser", fields: [approvedBy], references: [walletAddress])
  NftContract         NftContract @relation("ContractDrops", fields: [artistAddress], references: [artistAddress])
  Whitelist           Whitelist?  @relation(fields: [whitelistId], references: [id])
  Auctions            Auction[]
  FeaturedDropConfig  Config?     @relation("ConfigFeaturedDrop")
  Lotteries           Lottery[]
  UserFavoriteDrops   User[]      @relation("userFavoriteDrops")
}

model Lottery {
  id                  Int          @id @default(autoincrement())
  dropId              Int
  isRefundable        Boolean      @default(false)
  isLive              Boolean      @default(false)
  contractAddress     String?      @db.Char(42)
  costPerTicketTokens Float        @default(0.0)
  costPerTicketPoints Int          @default(0)
  maxTickets          Int          @default(0)
  maxTicketsPerUser   Int          @default(0)
  prizesAwardedAt     DateTime?
  endTime             DateTime
  startTime           DateTime
  Drop                Drop         @relation(fields: [dropId], references: [id])
  Nfts                Nft[]
  PrizeProofs         PrizeProof[]
  Refunds             Refund[]
}

model Auction {
  id              Int          @id @default(autoincrement())
  dropId          Int
  lastUpdatedAt   DateTime?
  minimumPrice    String?
  settled         Boolean      @default(false)
  startTime       DateTime
  endTime         DateTime?
  isLive          Boolean      @default(false)
  nftId           Int          @unique
  winnerAddress   String?      @db.Char(42)
  claimedAt       DateTime?
  contractAddress String?      @db.Char(42)
  duration        Int?
  Drop            Drop         @relation(fields: [dropId], references: [id])
  Nft             Nft          @relation(fields: [nftId], references: [id])
  Bids            BidHistory[]
}

model SplitEntry {
  id                 Int      @id @default(autoincrement())
  destinationAddress String   @db.Char(42)
  splitterId         Int
  percent            Float
  Splitter           Splitter @relation(fields: [splitterId], references: [id])
}

model Splitter {
  id              Int           @id @default(autoincrement())
  splitterAddress String?       @db.Char(42)
  NftContract     NftContract[] @relation("Splitter")
  SplitterEntries SplitEntry[]
}

model WhitelistEntry {
  id          Int           @id @default(autoincrement())
  whitelistId Int
  minBalance  String?
  tokenId     BigInt?
  type        WhitelistType
  Whitelist   Whitelist     @relation(fields: [whitelistId], references: [id])
}

model Whitelist {
  id               Int              @id @default(autoincrement())
  contractAddress  String           @db.Char(42)
  name             String
  Drops            Drop[]
  WhitelistEntries WhitelistEntry[]
}

model Nft {
  id               Int          @id @default(autoincrement())
  name             String
  description      String
  metadataPath     String?
  s3Path           String
  tags             String?
  numberOfEditions Int          @default(0)
  isHidden         Boolean      @default(false)
  lotteryId        Int?
  price            Float?
  ownerAddress     String?      @db.Char(42)
  artistAddress    String?      @db.Char(42)
  s3PathOptimized  String
  arweavePath      String?
  height           Int?
  width            Int?
  tokenId          Int?
  NftContract      NftContract? @relation(fields: [artistAddress], references: [artistAddress])
  Lottery          Lottery?     @relation(fields: [lotteryId], references: [id])
  Auction          Auction?
  Offers           Offer[]
  PrizeProof       PrizeProof[]
}

model NftContract {
  contractAddress   String?   @unique @db.Char(42)
  artistAddress     String    @id @db.Char(42)
  royaltyPercentage Float     @default(0.0)
  splitterId        Int?
  Artist            User      @relation("ArtistContract", fields: [artistAddress], references: [walletAddress])
  Splitter          Splitter? @relation("Splitter", fields: [splitterId], references: [id])
  Drops             Drop[]    @relation("ContractDrops")
  ListingNfts       Nft[]
}

model PrizeProof {
  winnerAddress String    @db.Char(42)
  proof         String
  claimedAt     DateTime?
  createdAt     DateTime
  nftId         Int
  lotteryId     Int
  uri           String
  ticketNumber  Int
  Lottery       Lottery   @relation(fields: [lotteryId], references: [id])
  Nft           Nft       @relation(fields: [nftId], references: [id])
  User          User      @relation(fields: [winnerAddress], references: [walletAddress])

  @@id([lotteryId, winnerAddress, nftId])
}

model TokenTransaction {
  blockNumber    Int
  blockTimestamp Int
  from           String    @db.Char(42)
  to             String    @db.Char(42)
  value          String
  assetType      AssetType
  id             Int       @id @default(autoincrement())
  txHash         String    @db.Char(66)

  @@index([from, to])
}

model EarnedPoints {
  address           String   @id @db.Char(42)
  totalPointsEarned BigInt   @default(0)
  signedMessage     String
  updatedAt         DateTime @default(now())
  User              User     @relation(fields: [address], references: [walletAddress])
}

model RewardType {
  type               AssetType @id
  rewardRate         Float
  lastBlockInspected Int
  chainId            Int
  contract           String    @db.Char(42)
  startingBlock      Int
  positionSizeLimit  String    @default("0")
}

model User {
  walletAddress            String        @id @db.Char(42)
  email                    String?       @db.VarChar(40)
  webpage                  String?       @db.VarChar(50)
  createdAt                DateTime      @default(now())
  role                     Role          @default(USER)
  bio                      String?       @db.VarChar(400)
  profilePicture           String?
  username                 String?       @unique @db.VarChar(40)
  receiveEmailNotification Boolean       @default(true)
  instagramUsername        String?       @db.VarChar(40)
  mediumUsername           String?       @db.VarChar(40)
  bannerImageS3Path        String?
  country                  String?
  state                    String?
  twitterUsername          String?       @db.VarChar(40)
  Bids                     BidHistory[]
  DropsApproved            Drop[]        @relation("Drop_approvedByToUser")
  EarnedPoints             EarnedPoints?
  NftContract              NftContract?  @relation("ArtistContract")
  PrizeProofs              PrizeProof[]
  FavoriteDrops            Drop[]        @relation("userFavoriteDrops")

  @@index([walletAddress])
}

model Offer {
  id                 Int        @id @default(autoincrement())
  signer             String     @db.Char(42)
  nftContractAddress String     @db.Char(42)
  price              Float
  isSellOffer        Boolean
  signedOffer        String
  expiresAt          Int
  nftId              Int
  state              OfferState @default(ACTIVE)
  Nft                Nft        @relation(fields: [nftId], references: [id])
}

model Config {
  id             Int    @id @default(autoincrement())
  featuredDropId Int?   @unique
  welcomeMessage String
  gasLimitForTxs Int
  FeaturedDrop   Drop?  @relation("ConfigFeaturedDrop", fields: [featuredDropId], references: [id])
}

model Follow {
  walletAddress   String @db.Char(42)
  followedAddress String @db.Char(42)

  @@id([walletAddress, followedAddress])
}

model SaleEvent {
  id             Int           @id @default(autoincrement())
  eventType      SaleEventType
  eventId        Int
  seller         String        @db.Char(42)
  buyer          String        @db.Char(42)
  amountTokens   Float
  amountPoints   Int?
  amountUSD      Float?
  txHash         String?       @db.Char(66)
  blockTimestamp Int
}

model Refund {
  id               Int     @id @default(autoincrement())
  buyer            String  @db.Char(42)
  lotteryId        Int
  refundableTokens Float
  txHash           String? @db.Char(66)
  blockTimestamp   Int?
  Lottery          Lottery @relation(fields: [lotteryId], references: [id])

  @@unique([buyer, lotteryId])
}

model BidHistory {
  id             Int     @id @default(autoincrement())
  auctionId      Int
  bidderAddress  String  @db.Char(42)
  amount         Float
  blockTimestamp Int
  Auction        Auction @relation(fields: [auctionId], references: [id])
  Bidder         User    @relation(fields: [bidderAddress], references: [walletAddress])
}

enum OfferState {
  ACTIVE
  USED
  CANCELLED
  INVALID
}

enum AssetType {
  ETH_ASH
}

enum Role {
  USER
  ARTIST
  ADMIN
}

enum WhitelistType {
  WALLET
  ERC20
  ERC721
  ERC1155
  MERKLE
}

enum SaleEventType {
  LOTTERY
  AUCTION
  MARKETPLACE
}
