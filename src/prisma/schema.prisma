generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch"]
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_CONNECTION_POOL_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model Drop {
  id                               Int         @id @default(autoincrement())
  name                             String
  whitelistId                      Int?
  createdAt                        DateTime    @default(now())
  approvedAt                       DateTime?
  approvedBy                       String?     @db.Char(42)
  bannerImageS3Path                String
  description                      String
  artistAddress                    String      @db.Char(42)
  NftContract                      NftContract @relation("ContractDrops", fields:[artistAddress], references: [artistAddress])
  ApprovedByUser                   User?       @relation("Drop_approvedByToUser", fields: [approvedBy], references: [walletAddress])
  Whitelist                        Whitelist?  @relation(fields: [whitelistId], references: [id])
  Auctions                         Auction[]
  Lotteries                        Lottery[]
  UserFavoriteDrops                User[]      @relation("userFavoriteDrops")
}

model Lottery {
  id                          Int        @id @default(autoincrement()) 
  dropId                      Int    
  isRefundable                Boolean    @default(false) 
  isLive                      Boolean    @default(false)
  contractAddress             String?    @db.Char(42)
  costPerTicketTokens         Float      @default(0.0)
  costPerTicketPoints         Int        @default(0)
  maxTickets                  Int        @default(0)
  maxTicketsPerUser           Int        @default(0)
  prizesAwardedAt             DateTime?
  endTime                     DateTime
  startTime                   DateTime
  Drop                        Drop       @relation(fields: [dropId], references: [id])
  Nfts                        Nft[]
  PrizeProofs                 PrizeProof[]   
}

model Auction {
  id                    Int        @id @default(autoincrement())
  dropId                Int        
  lastUpdatedAt         DateTime?
  minimumPrice          String?
  settled               Boolean    @default(false)
  startTime             DateTime
  endTime               DateTime
  isLive                Boolean    @default(false) 
  nftId                 Int 
  winnerAddress         String?     @db.Char(42)
  claimedAt             DateTime?
  contractAddress       String?   @db.Char(42)
  Drop                  Drop @relation(fields: [dropId], references: [id])
  Nft                   Nft  @relation(fields: [nftId], references: [id])
}

model SplitEntry {
  id                 Int      @id @default(autoincrement())
  destinationAddress String   @db.Char(42)
  splitterId         Int
  percent            Float
  Splitter           Splitter @relation(fields: [splitterId], references: [id])
}

model Splitter {
  id                     Int          @id @default(autoincrement())
  splitterAddress        String?      @db.Char(42)
  NftContract            NftContract[] @relation("Splitter")
  SplitterEntries        SplitEntry[]
}

model WhitelistEntry {
  id          Int           @id @default(autoincrement())
  whitelistId Int
  minBalance  String?
  tokenId     BigInt?
  type        WhitelistType
  Whitelist   Whitelist     @relation(fields: [whitelistId], references: [id])
}

model Whitelist {
  id               Int              @id @default(autoincrement())
  contractAddress  String           @db.Char(42)
  name             String
  Drops            Drop[]
  WhitelistEntries WhitelistEntry[]
}

model Nft {
  id                       Int          @id @default(autoincrement())
  name                     String
  description              String
  metadataPath             String
  s3Path                   String
  s3PathOptimized          String
  tags                     String
  numberOfEditions         Int          @default(0)
  isHidden                 Boolean      @default(false)
  lotteryId                Int?
  price                    Float?
  ownerAddress             String?      @db.Char(42)
  artistAddress            String?      @db.Char(42) 
  PrizeProof               PrizeProof[]
  Auction                  Auction?  
  Lottery                  Lottery?     @relation(fields: [lotteryId], references: [id])
  NftContract              NftContract? @relation(fields: [artistAddress], references: [artistAddress])
  Offers                   Offer[]   
}

model NftContract {
  artistAddress          String  @id @db.Char(42)
  contractAddress        String? @db.Char(42)
  royaltyPercentage      Float       @default(0.0)
  splitterId             Int?  
  Splitter               Splitter?   @relation("Splitter", fields: [splitterId], references: [id])
  Artist                 User        @relation("ArtistContract", fields: [artistAddress], references: [walletAddress])
  Drops                  Drop[]  @relation("ContractDrops")
  ListingNfts            Nft[] 

  @@unique([contractAddress])      
}

model PrizeProof {
  winnerAddress String    @db.Char(42)
  proof         String
  claimedAt     DateTime?
  createdAt     DateTime
  nftId         Int
  lotteryId     Int
  uri           String
  Nft           Nft       @relation(fields: [nftId], references: [id])
  Lottery       Lottery   @relation(fields: [lotteryId], references: [id])
  
  @@id([lotteryId, winnerAddress, nftId])
}

model TokenTransaction {
  blockNumber    Int
  blockTimestamp Int
  from           String    @db.Char(42)
  to             String    @db.Char(42)
  value          String
  assetType      AssetType
  id             Int       @id @default(autoincrement())
  txHash         String    @db.Char(66)

  @@index([from, to])
}

model EarnedPoints {
  address           String   @id @db.Char(42)
  totalPointsEarned BigInt   @default(0)
  signedMessage     String
  updatedAt         DateTime @default(now())
  User              User     @relation(fields: [address], references: [walletAddress])
}

model RewardType {
  type               AssetType @id
  rewardRate         Float
  lastBlockInspected Int
  chainId            Int
  contract           String    @db.Char(42)
  startingBlock      Int
  positionSizeLimit  String    @default("0")
}

model User {
  walletAddress                 String        @id @db.Char(42)
  email                         String?       @db.VarChar(40)
  twitterUsername               String?       @db.VarChar(40)
  instagramUsername             String?       @db.VarChar(40)
  webpage                       String?       @db.VarChar(50)
  mediumUsername                String?       @db.VarChar(40)
  createdAt                     DateTime      @default(now())
  role                          Role          @default(USER)
  bio                           String?       @db.VarChar(200)
  profilePicture                String?
  bannerImageS3Path            	String?
  receiveEmailNotification      Boolean       @default(true)
  username                      String?       @db.VarChar(40)
  DropsApproved                 Drop[]        @relation("Drop_approvedByToUser")
  NftContract                   NftContract?  @relation("ArtistContract")
  EarnedPoints                  EarnedPoints?
  FavoriteDrops                 Drop[]        @relation("userFavoriteDrops")

  @@index([walletAddress])
  @@unique([username])
}

model Offer {
  id                       Int    @id @default(autoincrement())
  signer                   String @db.Char(42)
  nftContractAddress       String @db.Char(42)
  price                    Float
  nftId                    Int
  expiresAt                Int
  isSellOffer              Boolean
  signedOffer              String
  state                    OfferState @default(ACTIVE)
  Nft                      Nft   @relation(fields:[nftId], references: [id])
  
}

enum OfferState {
  ACTIVE
  USED
  CANCELLED
  INVALID
}

model Follow {
  walletAddress                 String @db.Char(42)
  followedAddress               String @db.Char(42)

  @@id([walletAddress, followedAddress])  
}

enum AssetType {
  ETH_ASH
}

enum Role {
  USER
  ARTIST
  ADMIN
}

enum WhitelistType {
  WALLET
  ERC20
  ERC721
  ERC1155
  MERKLE
}
